<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>. : Entrenamiento - MakingDevs : .</title>
  
  <link rel="stylesheet" href="css/bootstrap.css">
  <link rel="stylesheet" href="css/font-awesome.min.css">
  <link rel="stylesheet" href="css/starter-template.css">
  <link rel="stylesheet" href="css/docs.css">

</head>
<body>

  <header class="navbar navbar-inverse navbar-fixed-top bs-docs-nav" role="banner">
    <div class="container">
      <div class="navbar-header">
        <a class="navbar-brand" href="http://makingdevs.com">
          <img src="img/logo.png" alt="· MakingDevs ·">
        </a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li>
            <a href="toc.html">Table of Contents</a>
          </li>
        </ul>
      </div><!--/.nav-collapse -->
    </div>    
  </header>

  <div class="bs-header" id="content">
      <div class="container">
        <h1>Acceso a datos con Spring 4</h1>
        <div style="height:70px"> 
          <p id="p1">Nuestro compromiso es ofrecerte una experiencia que realce las habilidades de aquellas personas que se dedican a desarrollar software.</p>
          <p id="p2">Sabemos que la responsabilidad de crear aplicaciones debe de estar sustentada con habilidades que permitan garantizar la calidad de las mismas.</p>
          <p id="p3">“Making best code, through better developers”</p>
        </div>
      </div>
   </div><!--div del header fixed-->

  <div class="container">
    <div class="row">
      <h1>Manejo de transacciones</h1>
<hr/><p>Cuando escribimos a una base de datos, debemos asegurarnos que la integridad de los datos es mantenida cuando se realizan cambios dentro de una transacción.</p><p>Las transacciones juegan un rol importante en el desarrollo de software, asegurando que los datos y los recursos nunca se dejan en un estado incosistente.</p><h2>Conceptos esenciales</h2><p>En desarrollo de software tenemos un acrónimo para referirnos a las características del desarrollo a bases de datos relacionales: ACID</p>
<ul>
  <li><strong>Atomic</strong> - Las transacciones se componen de una o más actividades empaquetadas en conjunto como una sola unidad de trabajo. La <em>atomicidad</em> asegura que todas las operaciones de la transacción ocurran o que ninguno de ellas ocurran. Si todas las actividades tienen éxito, la operación en global es procesada. Si alguna de las actividades falla, toda la transacción falla y se deshace.</li>
  <li><strong>Consistent</strong> - Una vez que una transacción termina (con o sin éxito), el sistema se deja en un estado coherente con el negocio que modela. Los datos no deben corromperse con respecto a la realidad.</li>
  <li><strong>Isolated</strong> - Las transacciones deben permitir que varios usuarios trabajen con los mismos datos, sin el trabajo individual de cada usuario se enrede con los demás. Por lo tanto, las transacciones deben ser aisladas unas de otras, previniendo lecturas concurrentes y escribir sobre los mismos datos que se producen. Hay que tener en cuenta que el aislamiento suele implicar bloqueo a registros y/o las tablas en una base de datos.</li>
  <li><strong>Durable</strong> - Una vez que la transacción se ha completado, los resultados de la transacción deben ser permanentes para que permanezcan a pesar de cualquier tipo de caída de la aplicación. Normalmente, esto implica almacenar los resultados en una base de datos o alguna otra forma de almacenamiento persistente.</li>
</ul>
<div class="bs-callout bs-callout-info">
<h4><i class="icon-coffee"></i> Información de utilidad.</h4>
  <p>
    Para profundizar en este tema te recomendamos <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">Patterns of Enterprise Application Architecture de Martin Fowler</a>
  </a>
  </p>
</div><h2>Administración de transacciones con Spring</h2>
<blockquote>
  <p>El soporte comprensivo de transacciones de Spring es potencialmente la razón más importante de su uso e impacto dentro de la industria del software.</p>
</blockquote><p>Beneficios:</p>
<ul>
  <li>Modelo de programación consistente a través de diferentes API&rsquo;s como JTA, JDBC, Hibernate, JPA y JDO.</li>
  <li>Soporte para administración declarativa de transacciones</li>
  <li>Una API muy simple para la administración programática de transacciones, en comparación de la API de JTA que suele ser muy compleja.</li>
  <li>Excelente integración con las abstracciones de acceso a datos de Spring.</li>
</ul><h3>Ventajas del modelo de soporte transaccional</h3><p>En Java EE, solo tenemos dos elecciones para la administración de transacciones: <em>locales</em> o <em>globales</em>, ambas tienen un conjunto de características que las diferencian y tienen limitantes.</p><h4>Transacciones globales</h4><p>Habilitan trabajar con múltiples recursos transaccionales, tipicamente bases de datos relaciones y colas de mensajes. Los servidores de aplicaciones administran las transacciones a través de JTA. Siin embargo, una transacción manejada por JTA normalmente viene de una fuente en un JNDI, lo cual significa el uso de JNDI adicional al de JTA.</p><h4>Transacciones locales</h4><p>Están relacionadas a un recurso específico, como una transacción asociada a una conexión JDBC. Las transacciones locales quizá sean más fácil de usar, pero tienen desventajas significativas: no pueden trabajar a lo largo de múltiples recursos transaccionales. Por ejemplo el código que administra las transacciones usa una conexión JDBC que no puede correr con la API de JTA, debido a que el servidor de aplicaciones no está involucrado en la administración de la transacción.</p><h4>Modelo consistente de programación</h4><p>Spring resuelve las desventajas de las transacciones globales y locales. Habilita al desarrollador usar un modelo consistente de programación en cualquier entorno. Se escribe el código una vez, y puede beneficiarse de las diferentes estrategias de administración de transacciones en los diferentes ambientes. Y aunque provee enfoques programáticos y declarativos, los desarrolladores se inclinan más a estos útlimos.</p><p>Con el modelo programático, los desarrolladores trabajan con la abstracción de transacción de Spring. Con el modelo declarativo, tipicamente se escribe código que no tiene relación alguna con la administración de las transacciones, y no depende de la API de Spring, o de alguna otra API.</p>
<blockquote>
  <p>No necesitamos de un servidor de aplicaciones para el manejo de transacciones.</p>
</blockquote><p>La administración de transacciones de Spring soporta cambios a reglas tradicionales como cuando una aplicación Java requiere un servidor de aplicaciones.</p>
<div class="bs-callout bs-callout-warning">
<h4><i class="icon-coffee"></i> Información de utilidad.</h4>
  <p>
    Típicamente necesitas la capacidad de JTA del servidor de aplicaciones solamente si necesitas manejar transacciones a través de múltiples recursos, lo cual NO es un requerimiento en la mayoría de la aplicaciones. Muchas aplicaciones una sola base de datos única y escalable.
  </p>
</div>
<blockquote>
  <p>SpringFramework te da la elección de escalar la aplicación a un servidor de aplicaciones totalmente cargado cuando lo necesites.</p>
</blockquote><h2>Comprensión de los Manejadores de transacciones</h2><p>Spring emplea un mecanismo de <em>callback</em> que abstrae la implementación de la transacción actual del código de la transacción. Y si la aplicación usa un sólo recurso persistente, entonces Spring puede usar el soporte ofrecido por un mecanismo de persistencia. Pero si la aplicación tiene el requerimiento de cubrir varios recursos para una transacción, entonces Spring puede soportar transacciones distribuidas(XA) usando implementaciones de terceros de JTA.</p><p>El elemento principal de Spring para la abstracción transaccional es la noción de una estrategia de transacion(<em>transaction strategy</em>), la cual está definida por la interfaz <code>org.springframework.transaction.PlatformTransactionManager</code>:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> PlatformTransactionManager.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
      public interface PlatformTransactionManager {
        TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
        void commit(TransactionStatus status) throws TransactionException;
        void rollback(TransactionStatus status) throws TransactionException;
      }
    ]]></script>
  </div>
</div><p>Las implementaciones de esta interfaz son definidas como cualquier otro bean en el contenedor de IoC de Spring. Además manteniendo la filosofía de Spring, la excepción <code>TransactionException</code> puede ser arrojada por cualquier método de la interfaz, y la cual es <em>no checada</em>.</p><p>El método <code>getTransaction(...)</code> regresa un objeto <code>TransactionStatus</code>, dependiendo del objeto <code>TransactionDefinition</code>. Lo que hace <code>TransactionStatus</code> es representar una nueva transacción, o una transacción existente si una transacción coincidente existe en la pila de la llamada actual. La implicación de este último caso es que el <code>TransactionStatus</code> esta asociado con un hilo de ejecución.</p><p>La interface <code>TransactionDefinition</code> específica:</p>
<ul>
  <li><strong>Isolation</strong> - El grado el cual esta transacción esta aislada del trabajo de otras transacciones.</li>
  <li><strong>Propagation</strong> - Típicamente, todo el código se ejecuta dentro de una transacción, sin embargo, tenemos la opción de definir de definir el comportamiento en el evento de que un método transaccional sea ejecutado en la misma transacción o abra una nueva transacción suspendiendo la actual.</li>
  <li><strong>Timeout</strong> - Cuanto tiempo deberá correr esta transacción antes de se le haga rollback automático por superar dicho tiempo.</li>
  <li><strong>Read-only</strong> status - Modifica la transacción para asegurar que no alterarán los datos en una operación.</li>
</ul><p>La interface <code>TransactionStatus</code> provee de una forma simple para codificar la transacción y controlar el código de ejecución de la transacción, así mismo, buscar el estado de la transacción.</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> TransactionStatus.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
public interface TransactionStatus extends SavepointManager {

    boolean isNewTransaction();

    boolean hasSavepoint();

    void setRollbackOnly();

    boolean isRollbackOnly();

    void flush();

    boolean isCompleted();

}
    ]]></script>
  </div>
</div><h3> Definición de los manejadores de transacciones</h3>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> DataSourceTransactionManager</h4>
    <script type="syntaxhighlighter" class="brush: xml;"><![CDATA[
      <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
        <property name="driverClassName" value="${jdbc.driverClassName}" />
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
      </bean>

      <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
      </bean>
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> HibernateTransactionManager</h4>
    <script type="syntaxhighlighter" class="brush: xml;"><![CDATA[
    <bean id="sessionFactory" class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="mappingResources">
          <list>
            <value>com/makingdevs/model/User.hbm.xml</value>
            <!-- ... -->
          </list>
        </property>
        <property name="hibernateProperties">
          <value>
            hibernate.dialect=${hibernate.dialect}
          </value>
        </property>
      </bean>

      <bean id="txManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <property name="sessionFactory" ref="sessionFactory" />
      </bean>
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> JtaTransactionManager</h4>
    <script type="syntaxhighlighter" class="brush: xml;"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        http://www.springframework.org/schema/jee/spring-jee.xsd">

    <jee:jndi-lookup id="dataSource" jndi-name="jdbc/makingdevs"/>

    <bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />

</beans>
    ]]></script>
  </div>
</div><p>Otros manejadores de transacciones disponibles están en <code>org.springframework.transaction</code>:</p>
<ul>
  <li><code>jca.cci.connection.CciLocalTransactionManager</code></li>
  <li><code>jms.connection.JmsTransactionManager</code></li>
  <li><code>jms.connection.JmsTransactionManager102</code></li>
  <li><code>orm.jdo.JdoTransactionManager</code></li>
  <li><code>orm.jpa.JpaTransactionManager</code></li>
  <li><code>transaction.jta.OC4JJtaTransactionManager</code></li>
  <li><code>transaction.jta.WebLogicJtaTransactionManager</code></li>
  <li><code>transaction.jta.WebSphereUowTransactionManager</code></li>
</ul><h2>Programando transacciones</h2>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> TransactionTemplateConfig.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.practica8;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;

@Configuration
@ImportResource(value={"classpath:/com/makingdevs/practica1/DataSourceWithNamespace.xml"})
// Look ma!, I'm reusing the DataSource and the JdbcTemplate
@ComponentScan(basePackages={"com.makingdevs.practica4","com.makingdevs.practica8"})
public class TransactionTemplateConfig {
  
  @Autowired
  DataSource dataSource;

  @Bean
  public DataSourceTransactionManager transactionManager(){
    return new DataSourceTransactionManager(dataSource);
  }
  
  // Look ma!, I'm declaring the Transaction Template
  @Bean
  public TransactionTemplate transactionTemplate(){
    return new TransactionTemplate(transactionManager());
  }
}
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-6">
    <h4><i class="icon-code"></i> UserStoryServiceImpl.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.practica8;

import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.TransactionCallback;
import org.springframework.transaction.support.TransactionCallbackWithoutResult;
import org.springframework.transaction.support.TransactionTemplate;

import com.makingdevs.dao.UserStoryDao;
import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@Service
public class UserStoryServiceImpl implements UserStoryServiceChecked {

  @Autowired
  TransactionTemplate transactionTemplate;

  @Autowired
  UserStoryDao userStoryDao;

  @Override
  public void createUserStory(final UserStory userStory) {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
      @Override
      protected void doInTransactionWithoutResult(TransactionStatus status) {
        userStory.setDateCreated(new Date());
        userStory.setLastUpdated(new Date());
        userStoryDao.create(userStory);
      }
    });
  }

  @Override
  public List<UserStory> findUserStoriesByProject(final String codeName) {
    transactionTemplate.setReadOnly(true);
    List<UserStory> userStories = transactionTemplate.execute(new TransactionCallback<List<UserStory>>() {
      @Override
      public List<UserStory> doInTransaction(TransactionStatus status) {
        Project project = new Project();
        project.setCodeName(codeName);
        project.setId(1L);
        // TODO: Find project by codeName must be implemented...
        return userStoryDao.findAllByProject(project);
      }
    });
    transactionTemplate.setReadOnly(false);
    return userStories;
  }

  @Override
  public boolean isUserStoryDone(Long userStoryId) throws BusinessException {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
      @Override
      protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
          throw new BusinessException("CheckedExcpetion");
        } catch (BusinessException e) {
          e.printStackTrace();
        }
      }
    });
    return false;
  }

  @Override
  public UserStory findUserStoryByIdentifier(Long userStoryId) {
    transactionTemplate.execute(new TransactionCallbackWithoutResult() {
      @Override
      protected void doInTransactionWithoutResult(TransactionStatus status) {
        throw new UnsupportedOperationException("Runtime exception");
      }
    });
    return null;
  }

}
    ]]></script>
  </div>
  <div class="col-md-6">
    <h4><i class="icon-code"></i> ProgrammaticTransactionsTests.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.practica8;

import java.util.List;

import org.junit.Assert;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.MethodSorters;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = { TransactionTemplateConfig.class })
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class ProgrammaticTransactionsTests {

  @Autowired
  UserStoryServiceChecked userStoryService;

  @Test
  public void test1CreateUSWithTx() {
    UserStory us = new UserStory();
    us.setDescription("As an user...I want...Beacuse...");
    us.setEffort(5);
    us.setPriority(3);
    Project p = new Project();
    p.setId(1L);
    us.setProject(p);
    userStoryService.createUserStory(us);
    Assert.assertTrue(us.getId() > 0);
    System.out.println(us.getId());
  }

  @Test
  public void test2FindUSByProjectCodeNameWithTX() {
    List<UserStory> userStories = userStoryService.findUserStoriesByProject("PROJECTNAME");
    Assert.assertTrue(userStories.size() > 0);
  }

  @Test
  public void test3FindCheckedExceptionTX() throws BusinessException {
    userStoryService.isUserStoryDone(1L);
  }

  @Test(expected = RuntimeException.class)
  public void test4FindUncheckedExceptionTX() {
    userStoryService.findUserStoryByIdentifier(1L);
  }

}
    ]]></script>
  </div>
</div><p>Para poder apreciar mucho mejor el manejo de transacciones, te recomendamos habilites en tu logger algunos paquetes que reflejan el uso del <code>DataSource</code>:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> log4j.properties</h4>
    <script type="syntaxhighlighter" class="brush: plain;"><![CDATA[
log4j.category.org.springframework.beans.factory=INFO
log4j.category.org.springframework.transaction=DEBUG
log4j.category.org.springframework.jdbc=DEBUG
    ]]></script>
  </div>
</div><p>Y obtendrás una salida similar a la siguiente:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> Console output</h4>
    <script type="syntaxhighlighter" class="brush: plain;"><![CDATA[
DataSourceTransactionManager  - Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT
SimpleDriverDataSource  - Creating new JDBC Driver Connection to [jdbc:h2:mem:dataSource;DB_CLOSE_DELAY=-1]
DataSourceTransactionManager  - Acquired Connection [conn3: url=jdbc:h2:mem:dataSource user=SA] for JDBC transaction
DataSourceTransactionManager  - Switching JDBC Connection [conn3: url=jdbc:h2:mem:dataSource user=SA] to manual commit
JdbcTemplate  - Executing prepared SQL update
JdbcTemplate  - Executing prepared SQL statement [INSERT INTO user_story(DATE_CREATED,DESCRIPTION,EFFORT,LAST_UPDATED,PRIORITY,PROJECT_ID) VALUES(?,?,?,?,?,?);]
JdbcTemplate  - SQL update affected 1 rows
JdbcTemplate  - Executing prepared SQL query
JdbcTemplate  - Executing prepared SQL statement [SELECT id FROM user_story WHERE DESCRIPTION = ? AND PROJECT_ID = ?]
DataSourceTransactionManager  - Initiating transaction commit
DataSourceTransactionManager  - Committing JDBC transaction on Connection [conn3: url=jdbc:h2:mem:dataSource user=SA]
DataSourceTransactionManager  - Releasing JDBC Connection [conn3: url=jdbc:h2:mem:dataSource user=SA] after transaction
DataSourceUtils  - Returning JDBC Connection to DataSource
    ]]></script>
  </div>
</div><h2>Transacciones declarativas</h2><p><img src="img/tx.png" alt="Alt tx"/></p>
<div class="row">
  <div class="col-md-6">
    <h4><i class="icon-code"></i> UserStoryServiceImpl.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.practica9;

import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.makingdevs.dao.UserStoryDao;
import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@Service
public class UserStoryServiceImpl implements UserStoryServiceChecked {

  @Autowired
  UserStoryDao userStoryDao;

  @Override
  public void createUserStory(final UserStory userStory) {
    userStory.setDateCreated(new Date());
    userStory.setLastUpdated(new Date());
    userStoryDao.create(userStory);
  }

  @Override
  public List<UserStory> findUserStoriesByProject(final String codeName) {
    Project project = new Project();
    project.setCodeName(codeName);
    project.setId(1L);
    return userStoryDao.findAllByProject(project);
  }

  @Override
  public boolean isUserStoryDone(Long userStoryId) throws BusinessException {
    throw new BusinessException("Checked exception");
  }

  @Override
  public UserStory findUserStoryByIdentifier(Long userStoryId) {
    throw new UnsupportedOperationException("Runtime exception");
  }

}
    ]]></script>
  </div>
  <div class="col-md-6">
    <h4><i class="icon-code"></i> NoTxAppCtx.xml</h4>
    <script type="syntaxhighlighter" class="brush: xml;"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
  xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd">

  <jdbc:embedded-database type="H2" id="dataSource">
    <jdbc:script location="com/makingdevs/scripts/user.sql" />
    <jdbc:script location="com/makingdevs/scripts/project.sql" />
    <jdbc:script location="com/makingdevs/scripts/user_story.sql" />
    <jdbc:script location="com/makingdevs/scripts/task.sql" />
    <jdbc:script location="com/makingdevs/scripts/constraints.sql" />
  </jdbc:embedded-database>

  <bean
    class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
    <constructor-arg ref="dataSource" />
  </bean>

  <context:component-scan base-package="com.makingdevs.practica4" />
  <context:component-scan base-package="com.makingdevs.practica9" />

</beans>
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> DeclarativeTransactionsTests.java</h4>
    <script type="syntaxhighlighter" class="brush: java; highlight:[20,21,22];"><![CDATA[
package com.makingdevs.practica9;

import java.util.List;

import org.junit.Assert;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.MethodSorters;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "NoTxAppCtx.xml" })
//@ContextConfiguration(locations = { "NoTxAppCtx.xml","DeclarativeTxAppCtx.xml" })
//@ContextConfiguration(locations = { "NoTxAppCtx.xml","DeclarativeTxWithExceptionsAppCtx.xml" })
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class DeclarativeTransactionsTests {

  @Autowired
  UserStoryServiceChecked userStoryService;

  @Test
  public void test1CreateUSWithTx() {
    UserStory us = new UserStory();
    us.setDescription("As an user...I want...Beacuse...");
    us.setEffort(5);
    us.setPriority(3);
    Project p = new Project();
    p.setId(1L);
    us.setProject(p);
    userStoryService.createUserStory(us);
    Assert.assertTrue(us.getId() > 0);
    System.out.println(us.getId());
  }

  @Test
  public void test2FindUSByProjectCodeNameWithTX() {
    List<UserStory> userStories = userStoryService.findUserStoriesByProject("PROJECTNAME");
    Assert.assertTrue(userStories.size() > 0);
  }

  @Test(expected = BusinessException.class)
  public void test3FindCheckedExceptionTX() throws BusinessException {
    userStoryService.isUserStoryDone(1L);
  }

  @Test(expected = RuntimeException.class)
  public void test4FindUncheckedExceptionTX() {
    userStoryService.findUserStoryByIdentifier(1L);
  }

}
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-6">
    <h4><i class="icon-code"></i> DeclarativeTxAppCtx.xml</h4>
    <script type="syntaxhighlighter" class="brush: xml;"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

  <bean id="txManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
  </bean>

  <!-- the transactional advice (what happens; see the <aop:advisor/> bean 
    below) -->
  <tx:advice id="txAdvice" transaction-manager="txManager">
    <!-- the transactional semantics... -->
    <tx:attributes>
      <!-- all methods starting with get are read-only -->
      <tx:method name="find*" read-only="true" />
      <tx:method name="is*" read-only="true" />
      <!-- other methods use the default transaction settings (see below) -->
      <tx:method name="*" />
    </tx:attributes>
  </tx:advice>

  <aop:config>
    <aop:pointcut id="transactionServiceOperation"
      expression="execution(* com.makingdevs.practica9.*Service*.*(..))" />
    <aop:advisor advice-ref="txAdvice" pointcut-ref="transactionServiceOperation" />
  </aop:config>

</beans>
    ]]></script>
  </div>
  <div class="col-md-6">
    <h4><i class="icon-code"></i> DeclarativeTxWithExceptionsAppCtx.xml</h4>
    <script type="syntaxhighlighter" class="brush: xml; highlight:[21,29];"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

  <bean id="txManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
  </bean>

  <!-- the transactional advice (what happens; see the <aop:advisor/> bean 
    below) -->
  <tx:advice id="txAdvice" transaction-manager="txManager">
    <!-- the transactional semantics... -->
    <tx:attributes>
      <!-- all methods starting with get are read-only -->
      <tx:method name="find*" read-only="true" />
      <tx:method name="is*" read-only="true" rollback-for="com.makingdevs.services.BusinessException"/>
      <!-- other methods use the default transaction settings (see below) -->
      <tx:method name="*" />
    </tx:attributes>
  </tx:advice>

  <aop:config>
    <aop:pointcut id="transactionServiceOperation"
      expression="execution(* com.makingdevs..*Service*.*(..))" />
    <aop:advisor advice-ref="txAdvice" pointcut-ref="transactionServiceOperation" />
  </aop:config>

</beans>
    ]]></script>
  </div>
</div><h3>Configuración de <code>&lt;tx:advice/&gt;</code></h3><p>En <code>&lt;tx:method/&gt;</code> existen atributos transaccionales ya definidos:</p>
<ul>
  <li>El tipo de propagación es <code>REQUIRED</code> por defecto</li>
  <li>El nivel de aislamiento(isolation) es <code>DEFAULT</code></li>
  <li>La transacción es de lectura/escritura</li>
  <li>El timeout por default de la tranasacción es establecido por el manejador de transacciones suscrito(el manejador).</li>
  <li>Cualquier <code>RuntimeException</code> dispara el rollback de la transacción, no así, con cualquier <code>Exception</code> checada, a menos que se defina en las reglas.</li>
</ul><p>Aunque tu puedes cambiarlos como desees.</p><h2>Transacciones con anotaciones</h2>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> UserStoryServiceImpl.java</h4>
    <script type="syntaxhighlighter" class="brush: java; highlight:[17,31,40,46];"><![CDATA[
package com.makingdevs.practica10;

import java.util.Date;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.makingdevs.dao.UserStoryDao;
import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@Service
@Transactional
public class UserStoryServiceImpl implements UserStoryServiceChecked {

  @Autowired
  UserStoryDao userStoryDao;

  @Override
  public void createUserStory(final UserStory userStory) {
    userStory.setDateCreated(new Date());
    userStory.setLastUpdated(new Date());
    userStoryDao.create(userStory);
  }

  @Override
  @Transactional(readOnly = true)
  public List<UserStory> findUserStoriesByProject(final String codeName) {
    Project project = new Project();
    project.setCodeName(codeName);
    project.setId(1L);
    return userStoryDao.findAllByProject(project);
  }

  @Override
  @Transactional(readOnly = true, rollbackFor = BusinessException.class)
  public boolean isUserStoryDone(Long userStoryId) throws BusinessException {
    throw new BusinessException("Checked exception");
  }

  @Override
  @Transactional(readOnly = true)
  public UserStory findUserStoryByIdentifier(Long userStoryId) {
    throw new UnsupportedOperationException("Runtime exception");
  }

}
    ]]></script>
  </div>
</div>
<div class="row">
  <div class="col-md-6">
    <h4><i class="icon-code"></i> TransactionsAnnotationsAppCtx.xml</h4>
    <script type="syntaxhighlighter" class="brush: xml; highlight:[12];"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xmlns:jdbc="http://www.springframework.org/schema/jdbc"
  xmlns:context="http://www.springframework.org/schema/context"
  xsi:schemaLocation="http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd
    http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
    http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

  <tx:annotation-driven/>
  
  <import resource="../practica1/DataSourceWithNamespace.xml"/>

  <bean
    class="org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate">
    <constructor-arg ref="dataSource" />
  </bean>

  <context:component-scan base-package="com.makingdevs.practica4" />
  <context:component-scan base-package="com.makingdevs.practica10" />

  <bean id="transactionManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource" />
  </bean>

</beans>
    ]]></script>
  </div>
  <div class="col-md-6">
    <h4><i class="icon-code"></i> AnnotatedTransactionsConfig.java</h4>
    <script type="syntaxhighlighter" class="brush: java; highlight:[16];"><![CDATA[
package com.makingdevs.practica10;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.ImportResource;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@ImportResource(value={"classpath:/com/makingdevs/practica1/DataSourceWithNamespace.xml"})
@ComponentScan(basePackages={"com.makingdevs.practica4","com.makingdevs.practica10"})
@EnableTransactionManagement
public class AnnotatedTransactionsConfig {
  
  @Autowired
  DataSource dataSource;

  @Bean
  public DataSourceTransactionManager transactionManager(){
    return new DataSourceTransactionManager(dataSource);
  }

}
    ]]></script>
  </div>
</div><h2>Tipos de propagación y niveles de aislamiento</h2><h3>REQUIRED</h3><p><img src="img/required.png" alt="Alt required"/></p><h3>REQUIRES_NEW</h3><p><img src="img/requires_new.png" alt="Alt requires_new"/></p><h3>SUPPORTS</h3>
<ul>
  <li>Si existe una transacción la usa</li>
  <li>Si no existe, no levanta transacción</li>
</ul><p><img src="img/supports.png" alt="Alt supports"/></p><h3>MANDATORY</h3>
<ul>
  <li>Debe existir una transacción, si no existe falla y arroja excpeción</li>
</ul><p><img src="img/mandatory.png" alt="Alt mandatory"/></p><p><img src="img/mandatory2.png" alt="Alt mandatory2"/></p><h3>NOT_SUPPORTED</h3>
<ul>
  <li>Ejecuta código sin transacción</li>
  <li>Si existe alguna levantada entonces la suspende</li>
  <li>Si no existe transacción previa, no hay problema</li>
  <li>Solo se puede usar con el <code>JtaTransactionManager</code></li>
</ul><p><img src="img/not_supported.png" alt="Alt not_supported"/></p><h3>NEVER</h3>
<ul>
  <li>No admite ningún tipo de transacciones</li>
  <li>Falla si existe alguna transacción en curso</li>
</ul><p><img src="img/never.png" alt="Alt never"/></p><h3>NESTED</h3>
<ul>
  <li>Es similar a REQUIRED</li>
  <li>Crea una sola transacción</li>
  <li>Hace un <code>SavePoint</code> para dar rollback sobre dicho punto</li>
  <li>La transacción puede dar commit, a pesar de los rollbacks de transacciones NESTED</li>
  <li>Sólo disponible para <code>DataSourceTransactionManager</code></li>
</ul><p><img src="img/nested.png" alt="Alt nested"/></p><h3> Niveles de aislamiento</h3>
<ul>
  <li>ISOLATION_DEFAULT</li>
  <li>ISOLATION_READ_UNCOMMITTED</li>
  <li>ISOLATION_READ_COMMITTED</li>
  <li>ISOLATION_REPEATABLE_READ</li>
  <li>ISOLATION_SERIALIZABLE</li>
</ul><h2>Wrapping de excepciones</h2>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> Transformando excepciones</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.advices;

import org.apache.log4j.Logger;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Aspect;
import org.hibernate.exception.GenericJDBCException;
import org.springframework.core.annotation.Order;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.UncategorizedSQLException;
import org.springframework.stereotype.Component;
import org.springframework.transaction.CannotCreateTransactionException;

import com.makingdevs.services.BusinessException;

@Component
@Aspect
@Order(value = 1)
public class ServiceThrowsAdvice {

  Logger log = Logger.getLogger(this.getClass());

  @AfterThrowing(pointcut = "execution(* com.makingdevs.services..*.*(..))", throwing = "dataAccessEx")
  public void doRecoveryActionDataAccess(DataAccessException dataAccessEx)
      throws BusinessException {
    log.debug(dataAccessEx.getMessage());
    throw new BusinessException("Error en Persistencia: ", dataAccessEx);
  }

  @AfterThrowing(pointcut = "execution(* com.makingdevs.services..*.*(..))", throwing = "jdbcException")
  public void doRecoveryActionGenericJDBC(GenericJDBCException jdbcException)
      throws BusinessException {
    log.debug(jdbcException.getMessage());
    throw new BusinessException("Error en Persistencia: ", jdbcException);
  }

  @AfterThrowing(pointcut = "execution(* com.makingdevs..*.*(..))", throwing = "uncategorizedSQLException")
  public void doRecoveryUncategorized(
      UncategorizedSQLException uncategorizedSQLException)
      throws BusinessException {
    log.debug(uncategorizedSQLException.getMessage());
    throw new BusinessException("Error en SQL: ", uncategorizedSQLException);
  }

  @AfterThrowing(pointcut = "execution(* com.makingdevs.services..*.*(..))", throwing = "txException")
  public void doRecoveryCreateTransaction(
      CannotCreateTransactionException txException)
      throws BusinessException {
    log.debug(txException.getMessage());
    throw new BusinessException("Error en Persistencia: ", txException);
  }
}
    ]]></script>
  </div>
</div><h2>Soporte de Anotaciones para Testing</h2><p>Cualquiera de estas anotaciones puede ser usada para crear una nueva anotación que conjunte la funcionalidad deseada:</p>
<ul>
  <li><code>@ContextConfiguration</code></li>
  <li><code>@ContextHierarchy</code></li>
  <li><code>@ActiveProfiles</code></li>
  <li><code>@DirtiesContext</code></li>
  <li><code>@WebAppConfiguration</code></li>
  <li><code>@TestExecutionListeners</code></li>
  <li><code>@Transactional</code></li>
  <li><code>@BeforeTransaction</code></li>
  <li><code>@AfterTransaction</code></li>
  <li><code>@TransactionConfiguration</code></li>
  <li><code>@Rollback</code></li>
  <li><code>@Repeat</code></li>
  <li><code>@Timed</code></li>
  <li><code>@IfProfileValue</code></li>
  <li><code>@ProfileValueSourceConfiguration</code></li>
</ul><p>Suponiendo el caso donde:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> Anotaciones comúnes</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class AllDaoTests { }

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public class AllAnotherDaoTests { }
    ]]></script>
  </div>
</div><p>Podemos definir:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> Creación de una nueva anotación</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@ContextConfiguration({"/app-config.xml", "/test-data-access-config.xml"})
@ActiveProfiles("dev")
@Transactional
public @interface TransactionalDevTest { }
    ]]></script>
  </div>
</div><p>Y poder usarla en lugar de todo el conjunto completo:</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> Creación de una nueva anotación</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
@RunWith(SpringJUnit4ClassRunner.class)
@TransactionalDevTest
public class AllDaoTests { }

@RunWith(SpringJUnit4ClassRunner.class)
@TransactionalDevTest
public class AllAnotherDaoTests { }
    ]]></script>
  </div>
</div><h3> Administración de transacciones en pruebas</h3><p>En el frameworks de pruebas de Spring, las transacciones son manejadas por <code>TransactionalTestExecutionListener</code>, el cual es configurado por defecto aunque no se lo indiquemos. Y para habilitar el soporte de transaccciones debemos proveer de un <code>PlatformTransactionManager</code> en el contexto de la aplicación en la semántica de <code>@ContextCinfiguration</code>. Adicionalmente, debemos declarar con <code>@Transactional</code> las clases y métodos que deseamos sean transaccionales.</p><p>Si las transacciones no están habilitados para toda la clase de prueba, podemos anotar los métodos explícitamente con <code>@Transactional</code>. Para controlar si una operación debe hacer commit para un método de prueba en particular, podemos utilizar la anotación <code>@Rollback</code> para sobreescribir la configuración del rollback establecido por la transacción de forma general.</p>
<div class="row">
  <div class="col-md-12">
    <h4><i class="icon-code"></i> TestingSupportTransactionsTests.java</h4>
    <script type="syntaxhighlighter" class="brush: java;"><![CDATA[
package com.makingdevs.practica11;

import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.FixMethodOrder;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.MethodSorters;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.annotation.Rollback;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.transaction.AfterTransaction;
import org.springframework.test.context.transaction.BeforeTransaction;
import org.springframework.test.context.transaction.TransactionConfiguration;
import org.springframework.transaction.annotation.Transactional;

import com.makingdevs.model.Project;
import com.makingdevs.model.UserStory;
import com.makingdevs.services.BusinessException;
import com.makingdevs.services.UserStoryServiceChecked;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "../practica10/TransactionsAnnotationsAppCtx.xml" })
// @ContextConfiguration(classes = { AnnotatedTransactionsConfig.class })
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@TransactionConfiguration(transactionManager="transactionManager", defaultRollback=false)
@Transactional
public class TestingSupportTransactionsTests {

  private Log log = LogFactory.getLog(TestingSupportTransactionsTests.class);

  @Autowired
  UserStoryServiceChecked userStoryService;

  @BeforeTransaction
  public void verifyInitialDatabaseState() {
    log.debug("logic to verify the initial state before a transaction is started");
  }

  @Before
  public void setUpTestDataWithinTransaction() {
    log.debug("set up test data within the transaction");
  }

  @After
  public void tearDownWithinTransaction() {
    log.debug("execute \"tear down\" logic within the transaction");
  }

  @AfterTransaction
  public void verifyFinalDatabaseState() {
    log.debug("logic to verify the final state after transaction has rolled back");
  }

  @Test
  // overrides the class-level defaultRollback setting
  @Rollback(true)
  public void test1CreateUSWithTx() {
    UserStory us = new UserStory();
    us.setDescription("As an user...I want...Beacuse...");
    us.setEffort(5);
    us.setPriority(3);
    Project p = new Project();
    p.setId(1L);
    us.setProject(p);
    userStoryService.createUserStory(us);
    Assert.assertTrue(us.getId() > 0);
    System.out.println(us.getId());
  }

  @Test
  @Rollback(true)
  public void test2FindUSByProjectCodeNameWithTX() {
    List<UserStory> userStories = userStoryService.findUserStoriesByProject("PROJECTNAME");
    Assert.assertTrue(userStories.size() > 0);
  }

  @Test(expected = BusinessException.class)
  public void test3FindCheckedExceptionTX() throws BusinessException {
    userStoryService.isUserStoryDone(1L);
  }

  @Test(expected = RuntimeException.class)
  public void test4FindUncheckedExceptionTX() {
    userStoryService.findUserStoryByIdentifier(1L);
  }

}
    ]]></script>
  </div>
</div>
<div class="bs-callout bs-callout-info">
<h4><i class="icon-coffee"></i> Información de utilidad</h4>
  <p>
    Te recomendamos revisar la consola del log que ejecuta la prueba, verás que ahora los métodos de la prueba son transaccionales.
  </a>
  </p>
</div>
    </div>
  </div><!-- /.container -->

  <footer id="footer" class="footer">
    <div class="container">
      <p class="credit text-muted">Powered by <a href="http://makingdevs.com">MakingDevs.com</a>.</p>
    </div>
  </footer>

  <script src="js/jquery-1.10.2.min.js"></script>
  <script src="js/bootstrap.js"></script>
  <script type="text/javascript" src="js/shCore.js"></script>
  <script type="text/javascript" src="js/shBrushJScript.js"></script>
  <script type="text/javascript" src="js/shBrushGroovy.js"></script>
  <script type="text/javascript" src="js/shBrushCss.js"></script>
  <script type="text/javascript" src="js/shBrushJava.js"></script>
  <script type="text/javascript" src="js/shBrushPlain.js"></script>
  <script type="text/javascript" src="js/shBrushSql.js"></script>
  <script type="text/javascript" src="js/shBrushXml.js"></script>
  <script type="text/javascript" src="js/shBrushBash.js"></script>
  <script type="text/javascript" src="js/shBrushPython.js"></script>
  <link type="text/css" rel="stylesheet" href="css/shCoreDefault.css"/>
  <script type="text/javascript">SyntaxHighlighter.all();</script>  
  <script src="js/funciones.js"></script>
</body>
</html>
